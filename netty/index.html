<!DOCTYPE html>
<html lang="en">

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.71.0" />


<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.2.0/favicons/favicon.ico" />



<title>Netty - For recording and sharing</title>

<meta name="author" content="Qianjun Wang" />
<meta name="description" content="..." />

<meta name="keywords" content="..., ..., ..." />

<meta property="og:title" content="Netty" />
<meta property="og:description" content="..." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thediscoverer.github.io/netty/" />
<meta property="og:image" content="https://thediscoverer.github.io/img/og.png"/>
<meta property="article:published_time" content="2020-05-27T16:21:22+08:00" />
<meta property="article:modified_time" content="2020-05-27T16:21:22+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://thediscoverer.github.io/img/og.png"/>

<meta name="twitter:title" content="Netty"/>
<meta name="twitter:description" content="..."/>






<link rel="stylesheet" href="https://thediscoverer.github.io/css/main.min.css" />



<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.0/dist/jquery.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.0/lazysizes.min.js" integrity="sha256-h2tMEmhemR2IN4wbbdNjj9LaDIjzwk2hralQwfJmBOE=" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css" integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ=" crossorigin="anonymous" />
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.5/dist/medium-zoom.min.js" integrity="sha256-Jd9xef1tT52aCb+cAqhElj/9D3c99lQvEjyKOuPn3S4=" crossorigin="anonymous"></script>







<body class="d-flex flex-column h-100">
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 link-primary">
            <a class="main-title" href="https://thediscoverer.github.io">For recording and sharing</a>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-md-9 col-12 float-left" id="content">
                
<article>
    
    <h4 class="post-title">
        <a href="https://thediscoverer.github.io/netty/">Netty</a>
    </h4>
    <div class="post-meta link-alter">
        <time><i class="fas fa-calendar-day"></i>&nbsp;2020-05-27</time><span><i class="fas fa-file-alt"></i>&nbsp;1432 words</span><span><i class="fas fa-tag"></i>&nbsp;<a href="/tags/.../">...</a> <a href="/tags/.../">...</a> <a href="/tags/.../">...</a> </span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h2 id="一概念">一、概念</h2>
<h3 id="同步-异步">同步 异步</h3>
<p>同步指整个处理过顺序执行，当各个过程执行完毕，才返回结果。
异步通常是发送了调用的命令，无需等待调用的结果完成执行完毕就可以收到消息，然后继续执行后续的流程，调用的方法并行的执行。
对于网络IO中，同步指的是用户线程从内核缓冲区中读取数据并写入到用户区，而异步指的是系统内核线程完成数据从内核缓冲区写入到用户区，用户线程不需要进行读写处理了。</p>
<h3 id="io阻塞-非阻塞">IO阻塞 非阻塞</h3>
<p>阻塞和非阻塞是针对进程访问数据的时候IO的才做方式。阻塞方式下，读取或者写入函数一直等待直到完成，非阻塞方式下，读取或写入的方法会立刻返回一个状态值。</p>
<h2 id="二传统的bio编程">二、传统的BIO编程</h2>
<h3 id="同步阻塞式io方法">同步阻塞式IO方法</h3>
<p>服务器有一个Acceptor线程负责监听端口是否有客户端发起连接，监听到一个连接后创建一个worker线程进行处理。Acceptor继续循环监听。因此，worker线程的数量在兵法情况下和客户端连接数量成1:1关系，严重浪费计算机资源。
其中worker线程是同步的完成数据的读取，由于客户端数据发送比较慢或者网络延迟等原因，缓冲区没有数据可读，而worker线程仍然会处于阻塞状态，一直等待。</p>
<h3 id="同步阻塞io改进方式">同步阻塞IO改进方式</h3>
<p>为了避免出现一线程一连接的模型方式，后来演进出了通过线程池或者消息队列实现少量线程处理N个客户端的模型，但是底层仍然是采用同步阻塞是IO。利用线程池可以实现线程复用，当线程数量达到最大线程数，客户端发起的任务可以阻塞在任务队列中。从而避免每一个请求都需要创建一个独立线程浪费系统线程资源的问题。</p>
<p>其中的问题在于阻塞IO中，对socket的输入流进行读取操作时候，会一直阻塞下去直到发生了一下三件事情：</p>
<ul>
<li>有数据可读</li>
<li>可用的数据已经读取完毕</li>
<li>IO异常
因此当对方发送请求较慢或者网络传输较慢时，读取输入流的线程可能会长时间阻塞。</li>
</ul>
<p>同时针对写入时候，也就阻塞直到所有要发送的字节全部写入完毕，或者发生异常。当消息的接收方处理缓慢的时候，将不能及时的从TCP缓冲区读取消息，这将会导致发送方的TCP 的滑动窗口不断减小，降低写入速度。</p>
<p>因此读写操作都是同步阻塞的，阻塞的事件取决于对方IO线程的处理速度和网络的传输速度。</p>
<h3 id="三nio">三、NIO</h3>
<p>java在jdk1.4中引入nio，在读写数据时候可以实现非阻塞。关键的要素包括Channel，Selector，Buffer。参考文章<a href="https://blog.csdn.net/forezp/article/details/88414741" target="_blank">https://blog.csdn.net/forezp/article/details/88414741</a></p>
<h4 id="buffer">Buffer</h4>
<p>bio是面向字节流进行数据读写的，如InputStram或者OutputStream，并且流是单向传输。 nio中采用Buffer，数据先是从通道中读入到buffer，或者从buffer中写入到通道。NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p>
<h4 id="selector">Selector</h4>
<p>Channel和IO中的stream</p>
<h4 id="channel">Channel</h4>
<pre><code>
public class ServerConnect
{
    private static final int BUF_SIZE=1024;
    private static final int PORT = 8080;
    private static final int TIMEOUT = 3000;
    public static void main(String[] args)
    {
        selector();
    }
    public static void handleAccept(SelectionKey key) throws IOException{
        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();
        SocketChannel sc = ssChannel.accept();
        sc.configureBlocking(false);
        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));
    }
    public static void handleRead(SelectionKey key) throws IOException{
        SocketChannel sc = (SocketChannel)key.channel();
        ByteBuffer buf = (ByteBuffer)key.attachment();
        long bytesRead = sc.read(buf);
        while(bytesRead&gt;0){
            buf.flip();
            while(buf.hasRemaining()){
                System.out.print((char)buf.get());
            }
            System.out.println();
            buf.clear();
            bytesRead = sc.read(buf);
        }
        if(bytesRead == -1){
            sc.close();
        }
    }
    public static void handleWrite(SelectionKey key) throws IOException{
        ByteBuffer buf = (ByteBuffer)key.attachment();
        buf.flip();
        SocketChannel sc = (SocketChannel) key.channel();
        while(buf.hasRemaining()){
            sc.write(buf);
        }
        buf.compact();
    }
    public static void selector() {
        Selector selector = null;
        ServerSocketChannel ssc = null;
        try{
            selector = Selector.open();
            ssc= ServerSocketChannel.open();
            ssc.socket().bind(new InetSocketAddress(PORT));
            ssc.configureBlocking(false);
            ssc.register(selector, SelectionKey.OP_ACCEPT);
            while(true){
                if(selector.select(TIMEOUT) == 0){
                    System.out.println(&quot;==&quot;);
                    continue;
                }
                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();
                while(iter.hasNext()){
                    SelectionKey key = iter.next();
                    if(key.isAcceptable()){
                        handleAccept(key);
                    }
                    if(key.isReadable()){
                        handleRead(key);
                    }
                    if(key.isWritable() &amp;&amp; key.isValid()){
                        handleWrite(key);
                    }
                    if(key.isConnectable()){
                        System.out.println(&quot;isConnectable = true&quot;);
                    }
                    iter.remove();
                }
            }
        }catch(IOException e){
            e.printStackTrace();
        }finally{
            try{
                if(selector!=null){
                    selector.close();
                }
                if(ssc!=null){
                    ssc.close();
                }
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }
</code></pre>
    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>Unless otherwise noted, the content of this site is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0)</a>.</p>
    </blockquote>
</div>






            </div>
            
            <div class="col-md-3 col-12 float-left link-alter" id="sidebar">
                

<div class="widget-toc">
    <h5>TOC</h5>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一概念">一、概念</a>
      <ul>
        <li><a href="#同步-异步">同步 异步</a></li>
        <li><a href="#io阻塞-非阻塞">IO阻塞 非阻塞</a></li>
      </ul>
    </li>
    <li><a href="#二传统的bio编程">二、传统的BIO编程</a>
      <ul>
        <li><a href="#同步阻塞式io方法">同步阻塞式IO方法</a></li>
        <li><a href="#同步阻塞io改进方式">同步阻塞IO改进方式</a></li>
        <li><a href="#三nio">三、NIO</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>


<div class="widget-pages">
    <h5>Pages</h5>
    <ul>
        
        
        <li>
            <a href="/">Home</a>
        </li>
        
        <li>
            <a href="/about/">About</a>
        </li>
        
        <li>
            <a href="/index.xml" target="_blank">RSS</a>
        </li>
    </ul>
</div>

<div class="widget-tags">
    <h5>Tags</h5>
    <div>
        
    </div>
</div>

<div class="widget-links">
    <h5>Links</h5>
    <ul>
        
        <li>
            <a href="https://github.com/TheDiscoverer" target="_blank"><span>GitHub</span></a>
        </li>
        
    </ul>
</div>


            </div>
            
            
            
            <div id="scroll-top">
                <i class="fas fa-chevron-up"></i>
            </div>
            
        </div>
    </main>

    <footer>
    <div class="container-lg text-center">
        <p>&copy; 2020 <a href="https://thediscoverer.github.io">Qianjun Wang</a> | Powered by <a href="https://github.com/amzrk2/hugo-theme-fuji/" target="_blank">Fuji</a> & <a href="https://gohugo.io/" target="_blank">Hugo</a> </p>
    </div>
</footer>
    
<script>
    $(function () {
        mediumZoom('.img-zoomable', {
            margin: 32
        });
    });
</script>








<script>
    $('.widget-toc a').click(function () {
        $('html, body').animate({
            scrollTop: $($(this).attr('href')).offset().top
        });
    });
</script>



<script>
    $('#scroll-top').click(function () {
        $('html, body').animate({
            scrollTop: 0
        });
    });
</script>






</body>

</html>